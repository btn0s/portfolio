---
title: Shaders
description: A tool for creating custom GLSL fragment shaders using AI
---

import ShaderBuddy from "@/components/lab/shader-buddy";

# Generating Shaders with Claude 3.7

An experiment in generating GLSL shaders with AI.
<div className="not-prose">
  <ShaderBuddy />
</div>

## How It Works

1. Describe the shader effect you want to create
2. The AI analyzes your prompt and creates a technical specification
3. Using this spec, it generates valid GLSL code for Three.js
4. The shader renders instantly in your browser

## Core Concepts

Fragment shaders are programs that run on every pixel of your screen, determining their final color based on various inputs.

The generated shaders work with three key inputs:

- `vUv`: Normalized (0-1) texture coordinates for each pixel
- `uTime`: Continuous time value for animations
- `uResolution`: Screen dimensions for aspect ratio correction

These building blocks allow for creation of:
- Geometric patterns through coordinate manipulation
- Smooth animations using time-based functions
- Color transitions and gradients
- Responsive layouts that adapt to screen size


## Implementation

Using the Vercel AI SDK, we chain two steps together with carefully crafted prompts:

```ts
// Step 1: Technical description
const descriptionResult = streamObject({
  model: anthropic("claude-3-7-sonnet-20250219"),
  schema: z.object({
    description: z.string().describe("Technical description of the shader effect"),
  }),
  prompt: `${descriptionPrompt}\n\nUser prompt: ${context}`,
  temperature: 0.7,
}).toTextStreamResponse();

const description = await new Response(descriptionResult.body).text();

// Step 2: Generate GLSL
const result = streamObject({
  model: anthropic("claude-3-7-sonnet-20250219"),
  schema: shaderSchema,
  prompt: codePrompt.replace("{description}", description),
  temperature: 0.7,
});

return result.toTextStreamResponse();
```

The system uses detailed prompts that:
1. First analyze the request and create a technical spec (with controlled randomness via temperature)
2. Provide context about shader programming concepts and best practices
3. Guide the model to generate optimized, well-structured GLSL code

The generated shaders are validated to ensure they:
- Contain required uniform declarations
- Follow GLSL best practices
- Handle edge cases and performance considerations
- Include proper documentation
